0. Introduction 
"Socket address" is consist of IP address and Port number. 
소켓은 4계층 상위 계층과 하위 계층간의 정보를 주고 받기 위한 구멍이다. 


1. Understanding of Socket & Socket API
Socket connection run between two diff coms or be used for interprcess comu on a single com.

Berkeley Socket API Functions 

Basic operating function
socket() -> bind(): binding Socket with port&IP address on OS  -> 
listen(): used on server side, listening a connection request from client *only for TCP -> connect(): used ont he client side, assigning a free local port number to a socket, attempting to establish a new TCP conn. ->
accept() : used on serve side, accepting a received incoming attepmt, creating a new socket associated with the socket address pair (cli) of this conn. 

send,recv,sendto,close()

setsockopt() : set a particualr socket option

socketserver module :
It simplifies the task of writing network servers.

BaseServer(server_address, RequestHandlerClass)
This is superclass of all Server objects in the module. 

BaseRequestHandler
This is superclass of all request handler  objects in the module.
A concrete handler subclass  must define new handle() method.

 
1. create request handler class by subclassing the BaseRequestHandler class and overriding its handle() method 
2. create server classes, oassing the server's address and port, handler class
3. classs the handle_reqest() or serve_forveerer() method of BaseServer class.

2. 1:N 통신Day02 

여기까지는 1:1 통신만 가능하다. 
멀티쓰레딩 기법을 통해서나 Socket API 의 고유 기능을 통해 1:N 통신을 구현해야한다. 

Each request must be completed before the next request can be started 
The solution is to create a separate proces or thread to handle each request; the 
"ForkingMixIn" and "ThreadingMixIn" mix-in classes can be used to support asynchronous behav.

Why Thread? 
동작방식을 바꾸기 위해서이다. 

동작방식이란 뭐냐? 이때까지는 동기식 동작방식을 사용하였다. synchronus
한 동작을 처리중이면 해당 동작처리가 끝날때까지 다음 동작을 처리하는것이 불가능하다. 
동기식에서는 a와 b의 "선후관계"가 너무 명확한것이다. 

앞에서는 클라이언트1이 접속하고 있으면 다른 클라이언트가 접속하지 못하고, 클라1  접속이 끊어져야 클라2 접속이 가능했다. 
따라서 쓰레드를 통해서 동기식 동작방식을 비동기식으로 바꾸어야한다. 통상적으로 blocking 처리라고 한다. 

비동식이란?
 n개의 요청을 동시다발적으로 처리가능하다. 이를 non-blocking 처리라고 한다. 

Multi-Thread/Process
cpu에 의해서 실행되는 독립적인 프로그램을 통상적으로 프로세스라고 한다. 
멀티프로세스는 프로그램이 여러개 실행되는것이다. 

Multi-process 는 독립적인 프로그램을 각각 실행한다.
하지만 처리할 데이터가 많은 경우에는 하나의 데이터가여러  일꾼(쓰레드) 들에게 공유되어서 처리되는 경우가 있다. 이것이 Multi-Thread 기법이다. 

socketserver 를 사용하여 multi-threading server 를 만드는 steps 

Step1. 

class ThreadingTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
   pass

Mix-in class 를 통해 multi-threading 을 수행하는 TCP 서버를 만들 수 있다. 

Step2.
Request Handler 를 수정할 수 있다. 
threading.current_thread() 와 같은 메소드를 호출  가능.
사실 Request Handler 를 수정하지 않아도 된다. 

Step3. 
파이썬이 실행이 되면 이곳에서 핸들러가 실행이 된다. 파이썬 프로그램이 실행이 되는 본체도,
쓰레드화된다. 이를 "Main Thread" 라고 한다. 

if __name__ == "__main__"  아랫줄에 실행되는 코드가 메인 쓰레드화된다는 의미.
즉, 각각의 코드가 독립적인 쓰레드로서 동작한다. 
그리고 다음과 같은 경우가 있다. 
1.  메인 쓰레드가 죽었을때, 추가적인 쓰레드들도 죽었으면 좋겠을때.
2.  반대로, 죽어도 다른 쓰레드들도  살아있으면 좋겠다. 
통신 프로그램의 경우에는 1처럼 추가적인 쓰레드들을 먼저 죽이고, 메인 쓰레드를 죽이는것이 익숙하다. 

이것을 결정하는것이 daemon_threads. Default is false
When Main dies, others live. This is default action 
daemon 이 main이 죽어도 살아있는게 싫다면 이것을 True 로 설정.

threading.Thread(target=server.serve_forever) #create thread 
server_thread.start() #start the thread 
threading.active_count()
server_thread_Run() 

3. Asynchrouns chatting service
N:M communication 

클라이언트측 변경 내용 
Threading 을 사용하여 수신과 송신을 비동기적으로 분리
전송은 사용자로부터 키보드 입력을 받아야하므로 Thread 화 하지 않고,
수신은 서버의 echo 를 기다려야하는 것이므로, Thread 화 한다.


반복구문에 있어야할 Recv 처리를 별도의 함수 로 처리한다. (이경우에는 클래스가 아님)
그리고 클라이언트측의 recvHandler 를main 에서 Thread 화한다. 
clientThread = threading.Thread(target=recvHandler, args=(clientSocket,))

송신은 동기, 수신은 비동기식으로 동작하도록 Threading 화 해준다. 


서버측 변경 내용 
N:M 통신을 위해서 서버는 각 클라이언트의 socket 정보를 저장해아한다. 
연결해제 요청이 오면 저장딘 정보를 제거하는것. 
특정 client 의 메시지를 전체 client에 전송한다. 

4. UDP Echo server/client 
connect(), listen() 단계가 생략된다. 
TCP 의 경우 active socket 의 갯수를 파악 가능하지만, UDP 의 경우 message based, connection-less  이기 때문에 클라이언트의 소켓 정보를 가지고 있지 않다. 따라서 클라이언트들이 직접 자신들이 연결했다는것을 알려주는것이 일반적이다. 
#REG or #DEREG 기능 구현 


You get remote address information with every incoming UDP datagram, so you konw who it's from, so you don'y need a per-connection socket to tell you. 
You must explicitly give  client address to sendto function since there's no socket connection to client.

