0. Introduction 
"Socket address" is consist of IP address and Port number. 
소켓은 4계층 상위 계층과 하위 계층간의 정보를 주고 받기 위한 구멍이다. 


1. Understanding of Socket & Socket API
Socket connection run between two diff coms or be used for interprcess comu on a single com.

Berkeley Socket API Functions 

Basic operating function
socket() -> bind(): binding Socket with port&IP address on OS  -> 
listen(): used on server side, listening a connection request from client *only for TCP -> connect(): used ont he client side, assigning a free local port number to a socket, attempting to establish a new TCP conn. ->
accept() : used on serve side, accepting a received incoming attepmt, creating a new socket associated with the socket address pair (cli) of this conn. 

send,recv,sendto,close()

setsockopt() : set a particualr socket option

socketserver module :
It simplifies the task of writing network servers.

BaseServer(server_address, RequestHandlerClass)
This is superclass of all Server objects in the module. 

BaseRequestHandler
This is superclass of all request handler  objects in the module.
A concrete handler subclass  must define new handle() method.

 
1. create request handler class by subclassing the BaseRequestHandler class and overriding its handle() method 
2. create server classes, oassing the server's address and port, handler class
3. classs the handle_reqest() or serve_forveerer() method of BaseServer class.

2. 1:N 통신Day02 

여기까지는 1:1 통신만 가능하다. 
멀티쓰레딩 기법을 통해서나 Socket API 의 고유 기능을 통해 1:N 통신을 구현해야한다. 

Each request must be completed before the next request can be started 
The solution is to create a separate proces or thread to handle each request; the 
"ForkingMixIn" and "ThreadingMixIn" mix-in classes can be used to support asynchronous behav.

Why Thread? 
동작방식을 바꾸기 위해서이다. 

동작방식이란 뭐냐? 이때까지는 동기식 동작방식을 사용하였다. synchronus
한 동작을 처리중이면 해당 동작처리가 끝날때까지 다음 동작을 처리하는것이 불가능하다. 
동기식에서는 a와 b의 "선후관계"가 너무 명확한것이다. 

앞에서는 클라이언트1이 접속하고 있으면 다른 클라이언트가 접속하지 못하고, 클라1  접속이 끊어져야 클라2 접속이 가능했다. 
따라서 쓰레드를 통해서 동기식 동작방식을 비동기식으로 바꾸어야한다. 통상적으로 blocking 처리라고 한다. 

비동식이란?
 n개의 요청을 동시다발적으로 처리가능하다. 이를 non-blocking 처리라고 한다. 

Multi-Thread/Process
cpu에 의해서 실행되는 독립적인 프로그램을 통상적으로 프로세스라고 한다. 
멀티프로세스는 프로그램이 여러개 실행되는것이다. 

Multi-process 는 독립적인 프로그램을 각각 실행한다.
하지만 처리할 데이터가 많은 경우에는 하나의 데이터가여러  일꾼(쓰레드) 들에게 공유되어서 처리되는 경우가 있다. 이것이 Multi-Thread 기법이다. 

socketserver 를 사용하여 multi-threading server 를 만드는 steps 

Step1. 

class ThreadingTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
   pass

Mix-in class 를 통해 multi-threading 을 수행하는 TCP 서버를 만들 수 있다. 

Step2.
Request Handler 를 수정할 수 있다. 
threading.current_thread() 와 같은 메소드를 호출  가능.
사실 Request Handler 를 수정하지 않아도 된다. 

Step3. 
파이썬이 실행이 되면 이곳에서 핸들러가 실행이 된다. 파이썬 프로그램이 실행이 되는 본체도,
쓰레드화된다. 이를 "Main Thread" 라고 한다. 

if __name__ == "__main__"  아랫줄에 실행되는 코드가 메인 쓰레드화된다는 의미.
즉, 각각의 코드가 독립적인 쓰레드로서 동작한다. 
그리고 다음과 같은 경우가 있다. 
1.  메인 쓰레드가 죽었을때, 추가적인 쓰레드들도 죽었으면 좋겠을때.
2.  반대로, 죽어도 다른 쓰레드들도  살아있으면 좋겠다. 
통신 프로그램의 경우에는 1처럼 추가적인 쓰레드들을 먼저 죽이고, 메인 쓰레드를 죽이는것이 익숙하다. 

이것을 결정하는것이 daemon_threads. Default is false
When Main dies, others live. This is default action 
daemon 이 main이 죽어도 살아있는게 싫다면 이것을 True 로 설정.

threading.Thread(target=server.serve_forever) #create thread 
server_thread.start() #start the thread 
threading.active_count()
server_thread_Run() 

